import traceback
from difflib import ndiff
from datetime import datetime
from pymongo import DESCENDING

from fame.core.store import store
from fame.core.module import ProcessingModule
from fame.common.utils import u
from fame.common.mongo_dict import MongoDict
from fame.common.exceptions import ModuleExecutionError


# Action for when botnet is None
ACTION_ADDED = 'added'

# Action for when botnet is a string
ACTION_NEW = 'new'
ACTION_UPDATE = 'update'
ACTION_REMOVED = 'removed'


class MalwareConfig(ProcessingModule):
    """Base class for malware configuration analysis modules.

    This class makes it easier to analyze extracted malware configuration in
    order to track evolutions of configurations targeting your organization.
    This is what appears in the `Configs` tab of the Web UI.

    It relies on a shared configuration named 'malware_config' that contains
    one `monitor` per line, a monitor being a string that will be looked for in
    malware configurations.

    Subclasses should at least define :attr:`extraction_label` and
    :func:`fame.modules.processing.malware_config.MalwareConfig.get_config_blocks`.

    Attributes:
        extraction_label (string): label of the extraction that contains the
            malware configuration to analyze.
    """
    extraction_label = None

    named_configs = {
        'malware_config': {
            'description': 'Needed in order to be able to track malware targets',
            'config': [
                {
                    'name': 'monitor',
                    'type': 'text',
                    'description': 'List of patterns (strings) to look for in malware configurations. There should be one pattern per line.'
                }
            ]
        }
    }

    def family(self):
        """To implement. Return the name of the malware family.

        By default, it will use the module's trigger as family name.

        Returns:
            Name of the malware family (string).
        """
        return self.info['triggered_by']

    def botnet(self, content):
        """To implement. Return the name of the specific botnet.

        Useful in cases where several botnets are used, in order to track them
        separately.

        By default, returns ``None`` which means that config blocks will be added individually. If in your case, there is only one botnet, you should always return the same string of your choice.

        Returns:
            Name of the specific botnet (string)
        """
        return None

    def is_parsable(self, content):
        """To implement. Check if extracted configuration can be parsed.

        Returns:
            ``True`` (default) if configuration can be parsed, ``False``
            otherwise.
        """
        return True

    def get_config_blocks(self, content):
        """To implement. Extract distinct blocks from complete configuration.

        This method must be defined in subclasses, and **generate** (with
        ``yield``) a list of individual config blocks in the form of tuples
        with the following elements, in this order:

        * **target** (string): specific target of the malware. Could be a domain
            name, a URL, an application name...
        * **type** (string): the type of operation conducted by the malware on
            this specific target. Examples: inject, screenshot...
        * **content** (string): the actual raw configuration block.
        * **additional** (string): any additional information than could be
            produced for the module. For example, if the malware is using
            dynamic injects, it could be the content of this inject.
        """
        raise NotImplementedError

    def run(self):
        result = False
        self.results = []

        # If the module has been defined as a target,
        # it should act on the main file
        # This allows analysts to directly submit a config file
        if self._analysis['module'] == self.name:
            with open(self._analysis.get_main_file(), 'rb') as f:
                return self._try_each('main', f.read())
        # Otherwise, we will try to find a matching extraction
        else:
            for extraction in self._analysis['extractions']:
                if extraction['label'] == self.extraction_label:
                    if self._try_each(self.extraction_label, extraction['content']):
                        result = True

        return result

    def each(self, content):
        content = u(content)
        found = []

        # First, save whole configuration
        botnet = self.botnet(content)
        if botnet:
            self.label = "{}:{}".format(self.family(), self.botnet(content))
            self.load_current_state()
        else:
            self.label = self.family()

        self.add_raw_config(self.label, content)

        # Only process configuration if it matches some criterias
        if not self.is_parsable(content):
            return False

        self.load_monitored_targets()

        for target, type, content, additional in self.get_config_blocks(content):
            # For now, just check for inclusion in target
            # Maybe this will need improvement later in order not to miss anything
            for m in self.monitored:
                id = "{}:{}".format(target, type)
                if m in target and id not in found:
                    # We found a match, make sure to update database accordingly
                    found.append(id)
                    if botnet:
                        self.found_block(m, target, type, content, additional)
                    else:
                        self.found_block_without_botnet(m, target, type, content, additional)
                    break

        # At this point, every entry remaining in self.known has been removed
        if botnet:
            self.handle_removed_entries()

        # Manually add the results to the analysis
        if self.results:
            self._analysis.update_value(['results', self.name], self.results)

        # Always return False so that we do not trigger anything else
        return False

    # This adds the whole configuration to the 'configs store'
    def add_raw_config(self, label, content):
        raw_config = {
            'label': label,
            'content': content,
            'date': datetime.now()
        }
        store.configs.save(raw_config)

    def add_to_results(self, block, last=None):
        b = {
            '_id': block['_id'],
            'created': block['created'],
            'action': block['action'],
            'type': block['type'],
            'botnet': block['botnet'],
            'target': block['target'],
            'monitor': block['monitor'],
            'content': block['content']
        }

        if block['action'] == ACTION_UPDATE:
            b['diff'] = ''.join(ndiff(last['content'].splitlines(1), block['content'].splitlines(1)))

        self.results.append(b)

    def found_block_without_botnet(self, monitor, target, type, content, additional):
        # Look for an existing block with the same content
        block = ConfigBlock.get(
            botnet=self.label,
            monitor=monitor,
            type=type,
            target=target,
            content=content,
            additional=additional
        )

        if block:
            block.update_value('updated', datetime.now())
            block.append_to('analyses', self._analysis['_id'])
        else:
            block = ConfigBlock({
                'type': type,
                'botnet': self.label,
                'target': target,
                'monitor': monitor,
                'content': content,
                'additional': additional,
                'action': ACTION_ADDED
            })
            block['analyses'].append(self._analysis['_id'])
            block.save()

        self.add_to_results(block)

    # This will handle a block matching a monitored target
    def found_block(self, monitor, target, type, content, additional):
        block = None
        last = None
        action = ACTION_NEW

        # If we already had a match
        if type in self.known and target in self.known[type]:
            # If the content is the same, just update the date
            if (self.known[type][target]['content'] == content and
                self.known[type][target]['additional'] == additional):
                block = self.known[type][target]
                block.update_value('updated', datetime.now())
                block.append_to('analyses', self._analysis['_id'])
            # Otherwise, create a new block with action set as 'update'
            else:
                action = ACTION_UPDATE

            # Remove it from kown state, so that we can notice deleted entries
            last = self.known[type][target]
            del self.known[type][target]

        if block is None:
            block = ConfigBlock({
                'type': type,
                'botnet': self.label,
                'target': target,
                'monitor': monitor,
                'content': content,
                'additional': additional,
                'action': action
            })
            block['analyses'].append(self._analysis['_id'])
            block.save()

        self.add_to_results(block, last)

    # Takes every entry remaining in self.known and marks it as removed
    def handle_removed_entries(self):
        for type in self.known:
            for target in self.known[type]:
                block = ConfigBlock({
                    'botnet': self.label,
                    'type': type,
                    'target': target,
                    'monitor': self.known[type][target]['monitor'],
                    'action': ACTION_REMOVED,
                    'content': ''
                })
                block.save()

                self.add_to_results(block)

    # This will construct an array of monitored targets from a data file
    def load_monitored_targets(self):
        self.monitored = [m.strip() for m in self.malware_config.monitor.splitlines() if m and not m.startswith('#')]

    # This will look into the database for all previous entries regarding this botnet
    # And build the current state, according to this
    def load_current_state(self):
        self.known = {}
        blocks = store.config_blocks.find({'botnet': self.label})

        # First, we have to get each config block 'type' known
        for type in blocks.distinct('type'):
            self.known[type] = {}

            # This could probably be done in just one (complex) query
            targets = store.config_blocks.find({
                'botnet': self.label,
                'type': type
            }).distinct('target')

            for target in targets:
                last_known = store.config_blocks.find({
                    'botnet': self.label,
                    'type': type,
                    'target': target,
                }).sort('updated', DESCENDING).limit(1)[0]

                if last_known['action'] != ACTION_REMOVED:
                    self.known[type][target] = ConfigBlock(last_known)

    def _try_each(self, name, content):
        try:
            return self.each(content)
        except ModuleExecutionError as e:
            self.log("error", "Could not run on %s: %s" % (name, e))
            return False
        except:
            tb = traceback.format_exc()
            self.log("error", "Could not run on %s.\n %s" % (name, tb))
            return False


class ConfigBlock(MongoDict):
    collection_name = 'config_blocks'

    def __init__(self, values):
        self['created'] = datetime.now()
        self['updated'] = datetime.now()
        self['analyses'] = []
        MongoDict.__init__(self, values)
